<!DOCTYPE html>
<html lang="en" style='height:100%'>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <title>redux</title>
    <style>
         html,body{
            padding:0;
            margin:0;
        }
        .app {
            font-size: 16px;
            padding:0 15px;
            width:calc(100% - 30px);
            height:100%;
            overflow:hidden auto;
            background: #f5f8dc;
        }
        .bottom {
            margin-bottom: 16px;
        }

        pre{
            border-radius: 3px;
            font-size: 85%;
            line-height: 1.45;
            overflow: auto;
            padding: 16px;
            background: #f0f0f0;
            font-family:'Consolas';
        }
        .pl-c {color: #6a737d;}
        .pl-k {color: #d73a49;}
        .pl-en {color: #6f42c1;}
        .pl-c1{color: #005cc5;}
        .pl-smi {color: #24292e;}
    </style>
  </head>
<body style='height:100%'>
        <div class="app">
        <h1>redux</h1>
        <h3>目录</h3>
        <ol>
        <li><a href="#intro">前言</a></li>
        <li><a href="#state">状态管理器</a>
        <ul>
        <li>简单的状态管理器</li>
        <li>有计划的状态管理器</li>
        </ul>
        </li>
        <li><a href="#coordination">多文件协作</a>
        <ul>
        <li>reducer 的拆分和合并</li>
        <li>state 的拆分和合并</li>
        </ul>
        </li>
        <li><a href="#middleware">中间件 middleware</a></li>
        <li><a href="#redux">完整的 redux</a></li>
        <li><a href="#practice">最佳实践</a>
        <ul>
        <li>纯函数</li>
        </ul>
        </li>
        <li><a href="#summary">总结</a></li>
        </ol>
        <h3><div id='intro'>前言</div></h3>
        <p>记得开始接触 react 技术栈的时候，最难理解的地方就是 redux。全是新名词：reducer、store、dispatch、middleware 等等，我就理解 state 一个名词。</p>
        <p>网上找的 redux 文章，要不有一本书的厚度，要不很玄乎，晦涩难懂，越看越觉得难，越看越怕，信心都没有了！</p>
        <p>花了很长时间熟悉 redux，慢慢的发现它其实真的很简单。本章不会把 redux 的各种概念，名词解释一遍，这样和其他教程没有任何区别，没有太大意义。我会带大家从零实现一个完整的 redux，让大家知其然，知其所以然。</p>
        <p>开始前，你必须知道一些事情：</p>
        <ul>
        <li>redux 和 react 没有关系，redux 可以用在任何框架中，忘掉 react。</li>
        <li>connect 不属于 redux，它其实属于 react-redux，请先忘掉它，下一章节，我们会介绍它。</li>
        <li>请一定先忘记 reducer、store、dispatch、middleware 等等这些名词。</li>
        <li>redux 是一个状态管理器。</li>
        </ul>
        <p>Let's Go！</p>
        <h3><div id='state'>状态管理器</div></h3>
        <h4>简单的状态管理器</h4>
        <p>redux 是一个状态管理器，那什么是状态呢？状态就是数据，比如计数器中的 count。</p>
        <div class="bottom"><pre><span class="pl-k">let</span> state <span class="pl-k">=</span> {
        count<span class="pl-k">:</span> <span class="pl-c1">1</span>
        }</pre></div>
        <p>我们来使用下状态</p>
        <div class="bottom"><pre><span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-smi">state</span>.<span class="pl-smi">count</span>);</pre></div>
        <p>我们来修改下状态</p>
        <div class="bottom"><pre><span class="pl-smi">state</span>.<span class="pl-smi">count</span> <span class="pl-k">=</span> <span class="pl-c1">2</span>;</pre></div>
        <p>好了，现在我们实现了状态（计数）的修改和使用了。</p>
        <p>当然上面的有一个很明显的问题：修改 count 之后，使用 count 的地方不能收到通知。我们可以使用发布-订阅模式来解决这个问题。</p>
        <div class="bottom"><pre><span class="pl-c"><span class="pl-c">/*</span>------count 的发布订阅者实践------<span class="pl-c">*/</span></span>
        <span class="pl-k">let</span> state <span class="pl-k">=</span> {
        count<span class="pl-k">:</span> <span class="pl-c1">1</span>
        };
        <span class="pl-k">let</span> listeners <span class="pl-k">=</span> [];

        <span class="pl-c"><span class="pl-c">/*</span>订阅<span class="pl-c">*/</span></span>
        <span class="pl-k">function</span> <span class="pl-en">subscribe</span>(<span class="pl-smi">listener</span>) {
        <span class="pl-smi">listeners</span>.<span class="pl-c1">push</span>(listener);
        }

        <span class="pl-k">function</span> <span class="pl-en">changeCount</span>(<span class="pl-smi">count</span>) {
        <span class="pl-smi">state</span>.<span class="pl-smi">count</span> <span class="pl-k">=</span> count;
        <span class="pl-c"><span class="pl-c">/*</span>当 count 改变的时候，我们要去通知所有的订阅者<span class="pl-c">*/</span></span>
        <span class="pl-k">for</span> (<span class="pl-k">let</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">listeners</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>) {
            <span class="pl-k">const</span> <span class="pl-c1">listener</span> <span class="pl-k">=</span> listeners[i];
            <span class="pl-en">listener</span>();
        }
        }</pre></div>
        <p>我们来尝试使用下这个简单的计数状态管理器。</p>
        <div class="bottom"><pre><span class="pl-c"><span class="pl-c">/*</span>来订阅一下，当 count 改变的时候，我要实时输出新的值<span class="pl-c">*/</span></span>
        <span class="pl-en">subscribe</span>(() <span class="pl-k">=&gt;</span> {
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-smi">state</span>.<span class="pl-smi">count</span>);
        });

        <span class="pl-c"><span class="pl-c">/*</span>我们来修改下 state，当然我们不能直接去改 state 了，我们要通过 changeCount 来修改<span class="pl-c">*/</span></span>
        <span class="pl-en">changeCount</span>(<span class="pl-c1">2</span>);
        <span class="pl-en">changeCount</span>(<span class="pl-c1">3</span>);
        <span class="pl-en">changeCount</span>(<span class="pl-c1">4</span>);</pre></div>
        <p>现在我们可以看到，我们修改 count 的时候，会输出相应的 count 值。</p>
        <p>现在有两个新的问题摆在我们面前</p>
        <ul>
        <li>这个状态管理器只能管理 count，不通用</li>
        <li>公共的代码要封装起来</li>
        </ul>
        <p>我们尝试来解决这个问题，把公共的代码封装起来</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">createStore</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">initState</span>) {
        <span class="pl-k">let</span> state <span class="pl-k">=</span> initState;
        <span class="pl-k">let</span> listeners <span class="pl-k">=</span> [];

        <span class="pl-c"><span class="pl-c">/*</span>订阅<span class="pl-c">*/</span></span>
        <span class="pl-k">function</span> <span class="pl-en">subscribe</span>(<span class="pl-smi">listener</span>) {
            <span class="pl-smi">listeners</span>.<span class="pl-c1">push</span>(listener);
        }

        <span class="pl-k">function</span> <span class="pl-en">changeState</span>(<span class="pl-smi">newState</span>) {
            state <span class="pl-k">=</span> newState;
            <span class="pl-c"><span class="pl-c">/*</span>通知<span class="pl-c">*/</span></span>
            <span class="pl-k">for</span> (<span class="pl-k">let</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">listeners</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>) {
            <span class="pl-k">const</span> <span class="pl-c1">listener</span> <span class="pl-k">=</span> listeners[i];
            <span class="pl-en">listener</span>();
            }
        }

        <span class="pl-k">function</span> <span class="pl-en">getState</span>() {
            <span class="pl-k">return</span> state;
        }

        <span class="pl-k">return</span> {
            subscribe,
            changeState,
            getState
        }
        }</pre></div>
        <p>我们来使用这个状态管理器管理多个状态 counter 和 info 试试</p>
        <div class="bottom"><pre><span class="pl-k">let</span> initState <span class="pl-k">=</span> {
        counter<span class="pl-k">:</span> {
            count<span class="pl-k">:</span> <span class="pl-c1">0</span>
        },
        info<span class="pl-k">:</span> {
            name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>,
            description<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span><span class="pl-pds">'</span></span>
        }
        }

        <span class="pl-k">let</span> store <span class="pl-k">=</span> <span class="pl-en">createStore</span>(initState);

        <span class="pl-smi">store</span>.<span class="pl-en">subscribe</span>(() <span class="pl-k">=&gt;</span> {
        <span class="pl-k">let</span> state <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-en">getState</span>();
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">`</span><span class="pl-s1"><span class="pl-pse">${</span><span class="pl-smi">state</span>.<span class="pl-smi">info</span>.<span class="pl-c1">name</span><span class="pl-pse">}</span></span>：<span class="pl-s1"><span class="pl-pse">${</span><span class="pl-smi">state</span>.<span class="pl-smi">info</span>.<span class="pl-c1">description</span><span class="pl-pse">}</span></span><span class="pl-pds">`</span></span>);
        });
        <span class="pl-smi">store</span>.<span class="pl-en">subscribe</span>(() <span class="pl-k">=&gt;</span> {
        <span class="pl-k">let</span> state <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-en">getState</span>();
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-smi">state</span>.<span class="pl-smi">counter</span>.<span class="pl-smi">count</span>);
        });

        <span class="pl-smi">store</span>.<span class="pl-en">changeState</span>({
        <span class="pl-k">...</span><span class="pl-smi">store</span>.<span class="pl-en">getState</span>(),
        info<span class="pl-k">:</span> {
            name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>前端九部<span class="pl-pds">'</span></span>,
            description<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>我们都是前端爱好者！<span class="pl-pds">'</span></span>
        }
        });

        <span class="pl-smi">store</span>.<span class="pl-en">changeState</span>({
        <span class="pl-k">...</span><span class="pl-smi">store</span>.<span class="pl-en">getState</span>(),
        counter<span class="pl-k">:</span> {
            count<span class="pl-k">:</span> <span class="pl-c1">1</span>
        }
        });</pre></div>
        <p>到这里我们完成了一个简单的状态管理器。</p>
        <p>这里需要理解的是 <code>createStore</code>，提供了 <code>changeState</code>，<code>getState</code>，<code>subscribe</code> 三个能力。</p>
        <p>本小节完整源码见 <a href="https://github.com/frontend9/redux-demo/tree/master/demo-1">demo-1</a></p>
        <h4>有计划的状态管理器</h4>
        <p>我们用上面的状态管理器来实现一个自增，自减的计数器。</p>
        <div class="bottom"><pre><span class="pl-k">let</span> initState <span class="pl-k">=</span> {
        count<span class="pl-k">:</span> <span class="pl-c1">0</span>
        }
        <span class="pl-k">let</span> store <span class="pl-k">=</span> <span class="pl-en">createStore</span>(initState);

        <span class="pl-smi">store</span>.<span class="pl-en">subscribe</span>(() <span class="pl-k">=&gt;</span> {
        <span class="pl-k">let</span> state <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-en">getState</span>();
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-smi">state</span>.<span class="pl-smi">count</span>);
        });
        <span class="pl-c"><span class="pl-c">/*</span>自增<span class="pl-c">*/</span></span>
        <span class="pl-smi">store</span>.<span class="pl-en">changeState</span>({
        count<span class="pl-k">:</span> <span class="pl-smi">store</span>.<span class="pl-en">getState</span>().<span class="pl-smi">count</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>
        });
        <span class="pl-c"><span class="pl-c">/*</span>自减<span class="pl-c">*/</span></span>
        <span class="pl-smi">store</span>.<span class="pl-en">changeState</span>({
        count<span class="pl-k">:</span> <span class="pl-smi">store</span>.<span class="pl-en">getState</span>().<span class="pl-smi">count</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>
        });
        <span class="pl-c"><span class="pl-c">/*</span>我想随便改<span class="pl-c">*/</span></span>
        <span class="pl-smi">store</span>.<span class="pl-en">changeState</span>({
        count<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span>
        });</pre></div>
        <p>你一定发现了问题，count 被改成了字符串 <code>abc</code>，因为我们对 count 的修改没有任何约束，任何地方，任何人都可以修改。</p>
        <p>我们需要约束，不允许计划外的 count 修改，我们只允许 count 自增和自减两种改变方式！</p>
        <p>那我们分两步来解决这个问题</p>
        <ol>
        <li>制定一个 state 修改计划，告诉 store，我的修改计划是什么。</li>
        <li>修改 store.changeState 方法，告诉它修改 state 的时候，按照我们的计划修改。</li>
        </ol>
        <p>我们来设置一个 plan 函数，接收现在的 state，和一个 action，返回经过改变后的新的 state。</p>
        <div class="bottom"><pre><span class="pl-c"><span class="pl-c">/*</span>注意：action = {type:'',other:''}, action 必须有一个 type 属性<span class="pl-c">*/</span></span>
        <span class="pl-k">function</span> <span class="pl-en">plan</span>(<span class="pl-smi">state</span>, <span class="pl-smi">action</span>) {
        <span class="pl-k">switch</span> (<span class="pl-smi">action</span>.<span class="pl-c1">type</span>) {
            <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>INCREMENT<span class="pl-pds">'</span></span>:
            <span class="pl-k">return</span> {
                <span class="pl-k">...</span>state,
                count<span class="pl-k">:</span> <span class="pl-smi">state</span>.<span class="pl-smi">count</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>
            }
            <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>DECREMENT<span class="pl-pds">'</span></span>:
            <span class="pl-k">return</span> {
                <span class="pl-k">...</span>state,
                count<span class="pl-k">:</span> <span class="pl-smi">state</span>.<span class="pl-smi">count</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>
            }
            <span class="pl-k">default</span>:
            <span class="pl-k">return</span> state;
        }
        }</pre></div>
        <p>我们把这个计划告诉 store，store.changeState 以后改变 state 要按照我的计划来改。</p>
        <div class="bottom"><pre><span class="pl-c"><span class="pl-c">/*</span>增加一个参数 plan<span class="pl-c">*/</span></span>
        <span class="pl-k">const</span> <span class="pl-c1">createStore</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">plan</span>, <span class="pl-smi">initState</span>) {
        <span class="pl-k">let</span> state <span class="pl-k">=</span> initState;
        <span class="pl-k">let</span> listeners <span class="pl-k">=</span> [];

        <span class="pl-k">function</span> <span class="pl-en">subscribe</span>(<span class="pl-smi">listener</span>) {
            <span class="pl-smi">listeners</span>.<span class="pl-c1">push</span>(listener);
        }

        <span class="pl-k">function</span> <span class="pl-en">changeState</span>(<span class="pl-smi">action</span>) {
            <span class="pl-c"><span class="pl-c">/*</span>请按照我的计划修改 state<span class="pl-c">*/</span></span>  
            state <span class="pl-k">=</span> <span class="pl-en">plan</span>(state, action);
            <span class="pl-k">for</span> (<span class="pl-k">let</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">listeners</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>) {
            <span class="pl-k">const</span> <span class="pl-c1">listener</span> <span class="pl-k">=</span> listeners[i];
            <span class="pl-en">listener</span>();
            }
        }

        <span class="pl-k">function</span> <span class="pl-en">getState</span>() {
            <span class="pl-k">return</span> state;
        }

        <span class="pl-k">return</span> {
            subscribe,
            changeState,
            getState
        }
        }</pre></div>
        <p>我们来尝试使用下新的 createStore 来实现自增和自减</p>
        <div class="bottom"><pre><span class="pl-k">let</span> initState <span class="pl-k">=</span> {
        count<span class="pl-k">:</span> <span class="pl-c1">0</span>
        }
        <span class="pl-c"><span class="pl-c">/*</span>把plan函数<span class="pl-c">*/</span></span>
        <span class="pl-k">let</span> store <span class="pl-k">=</span> <span class="pl-en">createStore</span>(plan, initState);

        <span class="pl-smi">store</span>.<span class="pl-en">subscribe</span>(() <span class="pl-k">=&gt;</span> {
        <span class="pl-k">let</span> state <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-en">getState</span>();
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-smi">state</span>.<span class="pl-smi">count</span>);
        });
        <span class="pl-c"><span class="pl-c">/*</span>自增<span class="pl-c">*/</span></span>
        <span class="pl-smi">store</span>.<span class="pl-en">changeState</span>({
        type<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>INCREMENT<span class="pl-pds">'</span></span>
        });
        <span class="pl-c"><span class="pl-c">/*</span>自减<span class="pl-c">*/</span></span>
        <span class="pl-smi">store</span>.<span class="pl-en">changeState</span>({
        type<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>DECREMENT<span class="pl-pds">'</span></span>
        });
        <span class="pl-c"><span class="pl-c">/*</span>我想随便改 计划外的修改是无效的！<span class="pl-c">*/</span></span>
        <span class="pl-smi">store</span>.<span class="pl-en">changeState</span>({
        count<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>abc<span class="pl-pds">'</span></span>
        });</pre></div>
        <p>到这里为止，我们已经实现了一个有计划的状态管理器！</p>
        <p>我们商量一下吧？我们给 plan 和 changeState 改下名字好不好？**plan 改成 reducer，changeState 改成 dispatch！**不管你同不同意，我都要换，因为新名字比较厉害（其实因为 redux 是这么叫的）!</p>
        <p>本小节完整源码见 <a href="https://github.com/frontend9/redux-demo/tree/master/demo-2">demo-2</a></p>
        <h3><div id="coordination">多文件协作</div></h3>
        <h4>reducer 的拆分和合并</h4>
        <p>这一小节我们来处理下 reducer 的问题。啥问题？</p>
        <p>我们知道 reducer 是一个计划函数，接收老的 state，按计划返回新的 state。那我们项目中，有大量的 state，每个 state 都需要计划函数，如果全部写在一起会是啥样子呢？</p>
        <p>所有的计划写在一个 reducer 函数里面，会导致 reducer 函数及其庞大复杂。按经验来说，我们肯定会按组件维度来拆分出很多个 reducer 函数，然后通过一个函数来把他们合并起来。</p>
        <p>我们来管理两个 state，一个 counter，一个 info。</p>
        <div class="bottom"><pre><span class="pl-k">let</span> state <span class="pl-k">=</span> {
        counter<span class="pl-k">:</span> {
            count<span class="pl-k">:</span> <span class="pl-c1">0</span>
        },
        info<span class="pl-k">:</span> {
            name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>前端九部<span class="pl-pds">'</span></span>,
            description<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>我们都是前端爱好者！<span class="pl-pds">'</span></span>
        }
        }</pre></div>
        <p>他们各自的 reducer</p>
        <div class="bottom"><pre><span class="pl-c"><span class="pl-c">/*</span>counterReducer, 一个子reducer<span class="pl-c">*/</span></span>
        <span class="pl-c"><span class="pl-c">/*</span>注意：counterReducer 接收的 state 是 state.counter<span class="pl-c">*/</span></span>
        <span class="pl-k">function</span> <span class="pl-en">counterReducer</span>(<span class="pl-smi">state</span>, <span class="pl-smi">action</span>) {
        <span class="pl-k">switch</span> (<span class="pl-smi">action</span>.<span class="pl-c1">type</span>) {
            <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>INCREMENT<span class="pl-pds">'</span></span>:
            <span class="pl-k">return</span> {
                count<span class="pl-k">:</span> <span class="pl-smi">state</span>.<span class="pl-smi">count</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>
            }
            <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>DECREMENT<span class="pl-pds">'</span></span>:
            <span class="pl-k">return</span> {
                <span class="pl-k">...</span>state,
                count<span class="pl-k">:</span> <span class="pl-smi">state</span>.<span class="pl-smi">count</span> <span class="pl-k">-</span> <span class="pl-c1">1</span>
            }
            <span class="pl-k">default</span>:
            <span class="pl-k">return</span> state;
        }
        }</pre></div>
        <div class="bottom"><pre><span class="pl-c"><span class="pl-c">/*</span>InfoReducer，一个子reducer<span class="pl-c">*/</span></span>
        <span class="pl-c"><span class="pl-c">/*</span>注意：InfoReducer 接收的 state 是 state.info<span class="pl-c">*/</span></span>
        <span class="pl-k">function</span> <span class="pl-en">InfoReducer</span>(<span class="pl-smi">state</span>, <span class="pl-smi">action</span>) {
        <span class="pl-k">switch</span> (<span class="pl-smi">action</span>.<span class="pl-c1">type</span>) {
            <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>SET_NAME<span class="pl-pds">'</span></span>:
            <span class="pl-k">return</span> {
                <span class="pl-k">...</span>state,
                name<span class="pl-k">:</span> <span class="pl-smi">action</span>.<span class="pl-c1">name</span>
            }
            <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>SET_DESCRIPTION<span class="pl-pds">'</span></span>:
            <span class="pl-k">return</span> {
                <span class="pl-k">...</span>state,
                description<span class="pl-k">:</span> <span class="pl-smi">action</span>.<span class="pl-c1">description</span>
            }
            <span class="pl-k">default</span>:
            <span class="pl-k">return</span> state;
        }
        }</pre></div>
        <p>那我们用 combineReducers 函数来把多个 reducer 函数合并成一个 reducer 函数。大概这样用</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">reducer</span> <span class="pl-k">=</span> <span class="pl-en">combineReducers</span>({
            counter<span class="pl-k">:</span> counterReducer,
            info<span class="pl-k">:</span> InfoReducer
        });</pre></div>
        <p>我们尝试实现下 combineReducers 函数</p>
        <div class="bottom"><pre><span class="pl-k">function</span> <span class="pl-en">combineReducers</span>(<span class="pl-smi">reducers</span>) {

        <span class="pl-c"><span class="pl-c">/*</span> reducerKeys = ['counter', 'info']<span class="pl-c">*/</span></span>
        <span class="pl-k">const</span> <span class="pl-c1">reducerKeys</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.<span class="pl-c1">keys</span>(reducers)

        <span class="pl-c"><span class="pl-c">/*</span>返回合并后的新的reducer函数<span class="pl-c">*/</span></span>
        <span class="pl-k">return</span> <span class="pl-k">function</span> <span class="pl-en">combination</span>(<span class="pl-smi">state</span> <span class="pl-k">=</span> {}, <span class="pl-smi">action</span>) {
            <span class="pl-c"><span class="pl-c">/*</span>生成的新的state<span class="pl-c">*/</span></span>
            <span class="pl-k">const</span> <span class="pl-c1">nextState</span> <span class="pl-k">=</span> {}

            <span class="pl-c"><span class="pl-c">/*</span>遍历执行所有的reducers，整合成为一个新的state<span class="pl-c">*/</span></span>
            <span class="pl-k">for</span> (<span class="pl-k">let</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">reducerKeys</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>) {
            <span class="pl-k">const</span> <span class="pl-c1">key</span> <span class="pl-k">=</span> reducerKeys[i]
            <span class="pl-k">const</span> <span class="pl-c1">reducer</span> <span class="pl-k">=</span> reducers[key]
            <span class="pl-c"><span class="pl-c">/*</span>之前的 key 的 state<span class="pl-c">*/</span></span>
            <span class="pl-k">const</span> <span class="pl-c1">previousStateForKey</span> <span class="pl-k">=</span> state[key]
            <span class="pl-c"><span class="pl-c">/*</span>执行 分 reducer，获得新的state<span class="pl-c">*/</span></span>
            <span class="pl-k">const</span> <span class="pl-c1">nextStateForKey</span> <span class="pl-k">=</span> <span class="pl-en">reducer</span>(previousStateForKey, action)

            nextState[key] <span class="pl-k">=</span> nextStateForKey
            }
            <span class="pl-k">return</span> nextState;
        }
        }</pre></div>
        <p>我们来尝试下 combineReducers 的威力吧</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">reducer</span> <span class="pl-k">=</span> <span class="pl-en">combineReducers</span>({
        counter<span class="pl-k">:</span> counterReducer,
        info<span class="pl-k">:</span> InfoReducer
        });

        <span class="pl-k">let</span> initState <span class="pl-k">=</span> {
        counter<span class="pl-k">:</span> {
            count<span class="pl-k">:</span> <span class="pl-c1">0</span>
        },
        info<span class="pl-k">:</span> {
            name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>前端九部<span class="pl-pds">'</span></span>,
            description<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>我们都是前端爱好者！<span class="pl-pds">'</span></span>
        }
        }

        <span class="pl-k">let</span> store <span class="pl-k">=</span> <span class="pl-en">createStore</span>(reducer, initState);

        <span class="pl-smi">store</span>.<span class="pl-en">subscribe</span>(() <span class="pl-k">=&gt;</span> {
        <span class="pl-k">let</span> state <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-en">getState</span>();
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-smi">state</span>.<span class="pl-smi">counter</span>.<span class="pl-smi">count</span>, <span class="pl-smi">state</span>.<span class="pl-smi">info</span>.<span class="pl-c1">name</span>, <span class="pl-smi">state</span>.<span class="pl-smi">info</span>.<span class="pl-c1">description</span>);
        });
        <span class="pl-c"><span class="pl-c">/*</span>自增<span class="pl-c">*/</span></span>
        <span class="pl-smi">store</span>.<span class="pl-en">dispatch</span>({
        type<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>INCREMENT<span class="pl-pds">'</span></span>
        });

        <span class="pl-c"><span class="pl-c">/*</span>修改 name<span class="pl-c">*/</span></span>
        <span class="pl-smi">store</span>.<span class="pl-en">dispatch</span>({
        type<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>SET_NAME<span class="pl-pds">'</span></span>,
        name<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>前端九部2号<span class="pl-pds">'</span></span>
        });</pre></div>
        <p>本小节完整源码见 <a href="https://github.com/frontend9/redux-demo/tree/master/demo-3">demo-3</a></p>
        <h4>state 的拆分和合并</h4>
        <p>上一小节，我们把 reducer 按组件维度拆分了，通过 combineReducers 合并了起来。但是还有个问题， state 我们还是写在一起的，这样会造成 state 树很庞大，不直观，很难维护。我们需要拆分，一个 state，一个 reducer 写一块。</p>
        <p>这一小节比较简单，我就不卖关子了，用法大概是这样（注意注释）</p>
        <div class="bottom"><pre><span class="pl-c"><span class="pl-c">/*</span> counter 自己的 state 和 reducer 写在一起<span class="pl-c">*/</span></span>
        <span class="pl-k">let</span> initState <span class="pl-k">=</span> {
        count<span class="pl-k">:</span> <span class="pl-c1">0</span>
        }
        <span class="pl-k">function</span> <span class="pl-en">counterReducer</span>(<span class="pl-smi">state</span>, <span class="pl-smi">action</span>) {
        <span class="pl-c"><span class="pl-c">/*</span>注意：如果 state 没有初始值，那就给他初始值！！<span class="pl-c">*/</span></span>  
        <span class="pl-k">if</span> (<span class="pl-k">!</span>state) {
            state <span class="pl-k">=</span> initState;
        }
        <span class="pl-k">switch</span> (<span class="pl-smi">action</span>.<span class="pl-c1">type</span>) {
            <span class="pl-k">case</span> <span class="pl-s"><span class="pl-pds">'</span>INCREMENT<span class="pl-pds">'</span></span>:
            <span class="pl-k">return</span> {
                count<span class="pl-k">:</span> <span class="pl-smi">state</span>.<span class="pl-smi">count</span> <span class="pl-k">+</span> <span class="pl-c1">1</span>
            }
            <span class="pl-k">default</span>:    
            <span class="pl-k">return</span> state;
        }
        }</pre></div>
        <p>我们修改下 createStore 函数，增加一行 <code>dispatch({ type: Symbol() })</code></p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">createStore</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">reducer</span>, <span class="pl-smi">initState</span>) {
        <span class="pl-k">let</span> state <span class="pl-k">=</span> initState;
        <span class="pl-k">let</span> listeners <span class="pl-k">=</span> [];

        <span class="pl-k">function</span> <span class="pl-en">subscribe</span>(<span class="pl-smi">listener</span>) {
            <span class="pl-smi">listeners</span>.<span class="pl-c1">push</span>(listener);
        }

        <span class="pl-k">function</span> <span class="pl-en">dispatch</span>(<span class="pl-smi">action</span>) {
            state <span class="pl-k">=</span> <span class="pl-en">reducer</span>(state, action);
            <span class="pl-k">for</span> (<span class="pl-k">let</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">listeners</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>) {
            <span class="pl-k">const</span> <span class="pl-c1">listener</span> <span class="pl-k">=</span> listeners[i];
            <span class="pl-en">listener</span>();
            }
        }

        <span class="pl-k">function</span> <span class="pl-en">getState</span>() {
            <span class="pl-k">return</span> state;
        }
        <span class="pl-c"><span class="pl-c">/*</span> 注意！！！只修改了这里，用一个不匹配任何计划的 type，来获取初始值 <span class="pl-c">*/</span></span>
        <span class="pl-en">dispatch</span>({ type<span class="pl-k">:</span> <span class="pl-c1">Symbol</span>() })

        <span class="pl-k">return</span> {
            subscribe,
            dispatch,
            getState
        }
        }</pre></div>
        <p>我们思考下这行可以带来什么效果？</p>
        <ol>
        <li>createStore 的时候，用一个不匹配任何 type 的 action，来触发 <code>state = reducer(state, action)</code></li>
        <li>因为 action.type 不匹配，每个子 reducer 都会进到 default 项，返回自己初始化的 state，这样就获得了初始化的 state 树了。</li>
        </ol>
        <p>你可以试试</p>
        <div class="bottom"><pre><span class="pl-c"><span class="pl-c">/*</span>这里没有传 initState 哦 <span class="pl-c">*/</span></span>
        <span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">createStore</span>(reducer);
        <span class="pl-c"><span class="pl-c">/*</span>这里看看初始化的 state 是什么<span class="pl-c">*/</span></span>
        <span class="pl-en">console</span>.<span class="pl-c1">dir</span>(<span class="pl-smi">store</span>.<span class="pl-en">getState</span>());</pre></div>
        <p>本小节完整源码见 <a href="https://github.com/frontend9/redux-demo/tree/master/demo-4">demo-4</a></p>
        <p>到这里为止，我们已经实现了一个七七八八的 redux 啦！</p>
        <h3><div id="middleware">中间件 middleware</div></h3>
        <p>中间件 middleware 是 redux 中最难理解的地方。但是我挑战一下用最通俗的语言来讲明白它。如果你看完这一小节，还没明白中间件是什么，不知道如何写一个中间件，那就是我的锅了！</p>
        <p>中间件是对 dispatch 的扩展，或者说重写，增强 dispatch 的功能！</p>
        <h4>记录日志</h4>
        <p>我现在有一个需求，在每次修改 state 的时候，记录下来 修改前的 state ，为什么修改了，以及修改后的 state。我们可以通过重写 store.dispatch 来实现，直接看代码</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">createStore</span>(reducer);
        <span class="pl-k">const</span> <span class="pl-c1">next</span> <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span>;

        <span class="pl-c"><span class="pl-c">/*</span>重写了store.dispatch<span class="pl-c">*/</span></span>
        <span class="pl-smi">store</span>.<span class="pl-en">dispatch</span> <span class="pl-k">=</span> (<span class="pl-smi">action</span>) <span class="pl-k">=&gt;</span> {
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>this state<span class="pl-pds">'</span></span>, <span class="pl-smi">store</span>.<span class="pl-en">getState</span>());
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>action<span class="pl-pds">'</span></span>, action);
        <span class="pl-en">next</span>(action);
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>next state<span class="pl-pds">'</span></span>, <span class="pl-smi">store</span>.<span class="pl-en">getState</span>());
        }</pre></div>
        <p>我们来使用下</p>
        <div class="bottom"><pre><span class="pl-smi">store</span>.<span class="pl-en">dispatch</span>({
        type<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>INCREMENT<span class="pl-pds">'</span></span>
        });</pre></div>
        <p>日志输出为</p>
        <div class="bottom"><pre><span class="pl-c1">this</span> state { counter<span class="pl-k">:</span> { count<span class="pl-k">:</span> <span class="pl-c1">0</span> } }
        action { type<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>INCREMENT<span class="pl-pds">'</span></span> }
        <span class="pl-c1">1</span>
        next state { counter<span class="pl-k">:</span> { count<span class="pl-k">:</span> <span class="pl-c1">1</span> } }</pre></div>
        <p>现在我们已经实现了一个完美的记录 state 修改日志的功能！</p>
        <h4>记录异常</h4>
        <p>我又有一个需求，需要记录每次数据出错的原因，我们扩展下 dispatch</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">createStore</span>(reducer);
        <span class="pl-k">const</span> <span class="pl-c1">next</span> <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span>;

        <span class="pl-smi">store</span>.<span class="pl-en">dispatch</span> <span class="pl-k">=</span> (<span class="pl-smi">action</span>) <span class="pl-k">=&gt;</span> {
        <span class="pl-k">try</span> {
            <span class="pl-en">next</span>(action);
        } <span class="pl-k">catch</span> (err) {
            <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">'</span>错误报告: <span class="pl-pds">'</span></span>, err)
        }
        }</pre></div>
        <p>这样每次 dispatch 出异常的时候，我们都会记录下来。</p>
        <h4>多中间件的合作</h4>
        <p>我现在既需要记录日志，又需要记录异常，怎么办？当然很简单了，两个函数合起来呗！</p>
        <div class="bottom"><pre><span class="pl-smi">store</span>.<span class="pl-en">dispatch</span> <span class="pl-k">=</span> (<span class="pl-smi">action</span>) <span class="pl-k">=&gt;</span> {
        <span class="pl-k">try</span> {
            <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>this state<span class="pl-pds">'</span></span>, <span class="pl-smi">store</span>.<span class="pl-en">getState</span>());
            <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>action<span class="pl-pds">'</span></span>, action);
            <span class="pl-en">next</span>(action);
            <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>next state<span class="pl-pds">'</span></span>, <span class="pl-smi">store</span>.<span class="pl-en">getState</span>());
        } <span class="pl-k">catch</span> (err) {
            <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">'</span>错误报告: <span class="pl-pds">'</span></span>, err)
        }
        }</pre></div>
        <p>如果又来一个需求怎么办？接着改 dispatch 函数？那再来10个需求呢？到时候 dispatch 函数肯定庞大混乱到无法维护了！这个方式不可取呀！</p>
        <p>我们需要考虑如何实现扩展性很强的多中间件合作模式。</p>
        <ol>
        <li>
        <p>我们把 loggerMiddleware 提取出来</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">createStore</span>(reducer);
        <span class="pl-k">const</span> <span class="pl-c1">next</span> <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span>;

        <span class="pl-k">const</span> <span class="pl-c1">loggerMiddleware</span> <span class="pl-k">=</span> (<span class="pl-smi">action</span>) <span class="pl-k">=&gt;</span> {
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>this state<span class="pl-pds">'</span></span>, <span class="pl-smi">store</span>.<span class="pl-en">getState</span>());
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>action<span class="pl-pds">'</span></span>, action);
        <span class="pl-en">next</span>(action);
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>next state<span class="pl-pds">'</span></span>, <span class="pl-smi">store</span>.<span class="pl-en">getState</span>());
        }

        <span class="pl-smi">store</span>.<span class="pl-en">dispatch</span> <span class="pl-k">=</span> (<span class="pl-smi">action</span>) <span class="pl-k">=&gt;</span> {
        <span class="pl-k">try</span> {
            <span class="pl-en">loggerMiddleware</span>(action);
        } <span class="pl-k">catch</span> (err) {
            <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">'</span>错误报告: <span class="pl-pds">'</span></span>, err)
        }
        }</pre></div>
        </li>
        <li>
        <p>我们把 exceptionMiddleware 提取出来</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">exceptionMiddleware</span> <span class="pl-k">=</span> (<span class="pl-smi">action</span>) <span class="pl-k">=&gt;</span> {
        <span class="pl-k">try</span> {
            <span class="pl-c"><span class="pl-c">/*</span>next(action)<span class="pl-c">*/</span></span>
            <span class="pl-en">loggerMiddleware</span>(action);
        } <span class="pl-k">catch</span> (err) {
            <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">'</span>错误报告: <span class="pl-pds">'</span></span>, err)
        } 
        }
        <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span> <span class="pl-k">=</span> exceptionMiddleware;</pre></div>
        </li>
        <li>
        <p>现在的代码有一个很严重的问题，就是 exceptionMiddleware 里面写死了 loggerMiddleware，我们需要让 <code>next(action)</code>变成动态的，随便哪个中间件都可以</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">exceptionMiddleware</span> <span class="pl-k">=</span> (<span class="pl-smi">next</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">action</span>) <span class="pl-k">=&gt;</span> {
        <span class="pl-k">try</span> {
            <span class="pl-c"><span class="pl-c">/*</span>loggerMiddleware(action);<span class="pl-c">*/</span></span>
            <span class="pl-en">next</span>(action);
        } <span class="pl-k">catch</span> (err) {
            <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">'</span>错误报告: <span class="pl-pds">'</span></span>, err)
        } 
        }
        <span class="pl-c"><span class="pl-c">/*</span>loggerMiddleware 变成参数传进去<span class="pl-c">*/</span></span>
        <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span> <span class="pl-k">=</span> <span class="pl-en">exceptionMiddleware</span>(loggerMiddleware);</pre></div>
        </li>
        <li>
        <p>同样的道理，loggerMiddleware 里面的 next 现在恒等于 store.dispatch，导致 loggerMiddleware 里面无法扩展别的中间件了！我们也把 next 写成动态的</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">loggerMiddleware</span> <span class="pl-k">=</span> (<span class="pl-smi">next</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">action</span>) <span class="pl-k">=&gt;</span> {
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>this state<span class="pl-pds">'</span></span>, <span class="pl-smi">store</span>.<span class="pl-en">getState</span>());
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>action<span class="pl-pds">'</span></span>, action);
        <span class="pl-en">next</span>(action);
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>next state<span class="pl-pds">'</span></span>, <span class="pl-smi">store</span>.<span class="pl-en">getState</span>());
        }</pre></div>
        </li>
        </ol>
        <p>到这里为止，我们已经探索出了一个扩展性很高的中间件合作模式！</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">createStore</span>(reducer);
        <span class="pl-k">const</span> <span class="pl-c1">next</span> <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span>;

        <span class="pl-k">const</span> <span class="pl-c1">loggerMiddleware</span> <span class="pl-k">=</span> (<span class="pl-smi">next</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">action</span>) <span class="pl-k">=&gt;</span> {
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>this state<span class="pl-pds">'</span></span>, <span class="pl-smi">store</span>.<span class="pl-en">getState</span>());
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>action<span class="pl-pds">'</span></span>, action);
        <span class="pl-en">next</span>(action);
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>next state<span class="pl-pds">'</span></span>, <span class="pl-smi">store</span>.<span class="pl-en">getState</span>());
        }

        <span class="pl-k">const</span> <span class="pl-c1">exceptionMiddleware</span> <span class="pl-k">=</span> (<span class="pl-smi">next</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">action</span>) <span class="pl-k">=&gt;</span> {
        <span class="pl-k">try</span> {
            <span class="pl-en">next</span>(action);
        } <span class="pl-k">catch</span> (err) {
            <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">'</span>错误报告: <span class="pl-pds">'</span></span>, err)
        }
        }

        <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span> <span class="pl-k">=</span> <span class="pl-en">exceptionMiddleware</span>(<span class="pl-en">loggerMiddleware</span>(next));</pre></div>
        <p>这时候我们开开心心的新建了一个 <code>loggerMiddleware.js</code>，一个<code>exceptionMiddleware.js</code>文件，想把两个中间件独立到单独的文件中去。会碰到什么问题吗？</p>
        <p>loggerMiddleware 中包含了外部变量 store，导致我们无法把中间件独立出去。那我们把 store 也作为一个参数传进去好了~</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">createStore</span>(reducer);
        <span class="pl-k">const</span> <span class="pl-c1">next</span>  <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span>;

        <span class="pl-k">const</span> <span class="pl-c1">loggerMiddleware</span> <span class="pl-k">=</span> (<span class="pl-smi">store</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">next</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">action</span>) <span class="pl-k">=&gt;</span> {
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>this state<span class="pl-pds">'</span></span>, <span class="pl-smi">store</span>.<span class="pl-en">getState</span>());
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>action<span class="pl-pds">'</span></span>, action);
        <span class="pl-en">next</span>(action);
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>next state<span class="pl-pds">'</span></span>, <span class="pl-smi">store</span>.<span class="pl-en">getState</span>());
        }

        <span class="pl-k">const</span> <span class="pl-c1">exceptionMiddleware</span> <span class="pl-k">=</span> (<span class="pl-smi">store</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">next</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">action</span>) <span class="pl-k">=&gt;</span> {
        <span class="pl-k">try</span> {
            <span class="pl-en">next</span>(action);
        } <span class="pl-k">catch</span> (err) {
            <span class="pl-en">console</span>.<span class="pl-c1">error</span>(<span class="pl-s"><span class="pl-pds">'</span>错误报告: <span class="pl-pds">'</span></span>, err)
        }
        }

        <span class="pl-k">const</span> <span class="pl-c1">logger</span> <span class="pl-k">=</span> <span class="pl-en">loggerMiddleware</span>(store);
        <span class="pl-k">const</span> <span class="pl-c1">exception</span> <span class="pl-k">=</span> <span class="pl-en">exceptionMiddleware</span>(store);
        <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span> <span class="pl-k">=</span> <span class="pl-en">exception</span>(<span class="pl-en">logger</span>(next));</pre></div>
        <p>到这里为止，我们真正的实现了两个可以独立的中间件啦！</p>
        <p>现在我有一个需求，在打印日志之前输出当前的时间戳。用中间件来实现！</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">timeMiddleware</span> <span class="pl-k">=</span> (<span class="pl-smi">store</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">next</span>) <span class="pl-k">=&gt;</span> (<span class="pl-smi">action</span>) <span class="pl-k">=&gt;</span> {
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-s"><span class="pl-pds">'</span>time<span class="pl-pds">'</span></span>, <span class="pl-k">new</span> <span class="pl-en">Date</span>().<span class="pl-c1">getTime</span>());
        <span class="pl-en">next</span>(action);
        }
        <span class="pl-k">...</span>
        <span class="pl-k">const</span> <span class="pl-c1">time</span> <span class="pl-k">=</span> <span class="pl-en">timeMiddleware</span>(store);
        <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span> <span class="pl-k">=</span> <span class="pl-en">exception</span>(<span class="pl-en">time</span>(<span class="pl-en">logger</span>(next)));</pre></div>
        <p>本小节完整源码见 <a href="https://github.com/frontend9/redux-demo/tree/master/demo-6">demo-6</a></p>
        <h4>中间件使用方式优化</h4>
        <p>上一节我们已经完全实现了正确的中间件！但是中间件的使用方式不是很友好</p>
        <div class="bottom"><pre><span class="pl-k">import</span> <span class="pl-smi">loggerMiddleware</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>./middlewares/loggerMiddleware<span class="pl-pds">'</span></span>;
        <span class="pl-k">import</span> <span class="pl-smi">exceptionMiddleware</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>./middlewares/exceptionMiddleware<span class="pl-pds">'</span></span>;
        <span class="pl-k">import</span> <span class="pl-smi">timeMiddleware</span> <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>./middlewares/timeMiddleware<span class="pl-pds">'</span></span>;

        <span class="pl-k">...</span>

        <span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">createStore</span>(reducer);
        <span class="pl-k">const</span> <span class="pl-c1">next</span> <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span>;

        <span class="pl-k">const</span> <span class="pl-c1">logger</span> <span class="pl-k">=</span> <span class="pl-en">loggerMiddleware</span>(store);
        <span class="pl-k">const</span> <span class="pl-c1">exception</span> <span class="pl-k">=</span> <span class="pl-en">exceptionMiddleware</span>(store);
        <span class="pl-k">const</span> <span class="pl-c1">time</span> <span class="pl-k">=</span> <span class="pl-en">timeMiddleware</span>(store);
        <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span> <span class="pl-k">=</span> <span class="pl-en">exception</span>(<span class="pl-en">time</span>(<span class="pl-en">logger</span>(next)));</pre></div>
        <p>其实我们只需要知道三个中间件，剩下的细节都可以封装起来！我们通过扩展 createStore 来实现！</p>
        <p>先来看看期望的用法</p>
        <div class="bottom"><pre><span class="pl-c"><span class="pl-c">/*</span>接收旧的 createStore，返回新的 createStore<span class="pl-c">*/</span></span>
        <span class="pl-k">const</span> <span class="pl-c1">newCreateStore</span> <span class="pl-k">=</span> <span class="pl-en">applyMiddleware</span>(exceptionMiddleware, timeMiddleware, loggerMiddleware)(createStore);

        <span class="pl-c"><span class="pl-c">/*</span>返回了一个 dispatch 被重写过的 store<span class="pl-c">*/</span></span>
        <span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">newCreateStore</span>(reducer);</pre></div>
        <p>实现 applyMiddleware</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">applyMiddleware</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-k">...</span><span class="pl-v">middlewares</span>) {
        <span class="pl-c"><span class="pl-c">/*</span>返回一个重写createStore的方法<span class="pl-c">*/</span></span>
        <span class="pl-k">return</span> <span class="pl-k">function</span> <span class="pl-en">rewriteCreateStoreFunc</span>(<span class="pl-smi">oldCreateStore</span>) {
            <span class="pl-c"><span class="pl-c">/*</span>返回重写后新的 createStore<span class="pl-c">*/</span></span>
            <span class="pl-k">return</span> <span class="pl-k">function</span> <span class="pl-en">newCreateStore</span>(<span class="pl-smi">reducer</span>, <span class="pl-smi">initState</span>) {
            <span class="pl-c"><span class="pl-c">/*</span>1. 生成store<span class="pl-c">*/</span></span>
            <span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">oldCreateStore</span>(reducer, initState);
            <span class="pl-c"><span class="pl-c">/*</span>给每个 middleware 传下store，相当于 const logger = loggerMiddleware(store);<span class="pl-c">*/</span></span>
            <span class="pl-c"><span class="pl-c">/*</span> const chain = [exception, time, logger]<span class="pl-c">*/</span></span>
            <span class="pl-k">const</span> <span class="pl-c1">chain</span> <span class="pl-k">=</span> <span class="pl-smi">middlewares</span>.<span class="pl-en">map</span>(<span class="pl-smi">middleware</span> <span class="pl-k">=&gt;</span> <span class="pl-en">middleware</span>(store));
            <span class="pl-k">let</span> dispatch <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span>;
            <span class="pl-c"><span class="pl-c">/*</span> 实现 exception(time((logger(dispatch))))<span class="pl-c">*/</span></span>
            <span class="pl-smi">chain</span>.<span class="pl-c1">reverse</span>().<span class="pl-en">map</span>(<span class="pl-smi">middleware</span> <span class="pl-k">=&gt;</span> {
                dispatch <span class="pl-k">=</span> <span class="pl-en">middleware</span>(dispatch);
            });

            <span class="pl-c"><span class="pl-c">/*</span>2. 重写 dispatch<span class="pl-c">*/</span></span>
            <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span> <span class="pl-k">=</span> dispatch;
            <span class="pl-k">return</span> store;
            }
        }
        }</pre></div>
        <h4>让用户体验美好</h4>
        <p>现在还有个小问题，我们有两种 createStore 了</p>
        <div class="bottom"><pre><span class="pl-c"><span class="pl-c">/*</span>没有中间件的 createStore<span class="pl-c">*/</span></span>
        <span class="pl-k">import</span> { <span class="pl-smi">createStore</span> } <span class="pl-k">from</span> <span class="pl-s"><span class="pl-pds">'</span>./redux<span class="pl-pds">'</span></span>;
        <span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">createStore</span>(reducer, initState);

        <span class="pl-c"><span class="pl-c">/*</span>有中间件的 createStore<span class="pl-c">*/</span></span>
        <span class="pl-k">const</span> <span class="pl-c1">rewriteCreateStoreFunc</span> <span class="pl-k">=</span> <span class="pl-en">applyMiddleware</span>(exceptionMiddleware, timeMiddleware, loggerMiddleware);
        <span class="pl-k">const</span> <span class="pl-c1">newCreateStore</span> <span class="pl-k">=</span> <span class="pl-en">rewriteCreateStoreFunc</span>(createStore);
        <span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">newCreateStore</span>(reducer, initState);</pre></div>
        <p>为了让用户用起来统一一些，我们可以很简单的使他们的使用方式一致，我们修改下 createStore 方法</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">createStore</span> <span class="pl-k">=</span> (<span class="pl-smi">reducer</span>, <span class="pl-smi">initState</span>, <span class="pl-smi">rewriteCreateStoreFunc</span>) <span class="pl-k">=&gt;</span> {
            <span class="pl-c"><span class="pl-c">/*</span>如果有 rewriteCreateStoreFunc，那就采用新的 createStore <span class="pl-c">*/</span></span>
            <span class="pl-k">if</span>(rewriteCreateStoreFunc){
            <span class="pl-k">const</span> <span class="pl-c1">newCreateStore</span> <span class="pl-k">=</span>  <span class="pl-en">rewriteCreateStoreFunc</span>(createStore);
            <span class="pl-k">return</span> <span class="pl-en">newCreateStore</span>(reducer, initState);
            }
            <span class="pl-c"><span class="pl-c">/*</span>否则按照正常的流程走<span class="pl-c">*/</span></span>
            <span class="pl-k">...</span>
        }</pre></div>
        <p>最终的用法</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">rewriteCreateStoreFunc</span> <span class="pl-k">=</span> <span class="pl-en">applyMiddleware</span>(exceptionMiddleware, timeMiddleware, loggerMiddleware);

        <span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">createStore</span>(reducer, initState, rewriteCreateStoreFunc);</pre></div>
        <p>本小节完整源码见 <a href="https://github.com/frontend9/redux-demo/tree/master/demo-7">demo-7</a></p>
        <h3><div id="redux">完整的 redux</div></h3>
        <h4>退订</h4>
        <p>不能退订的订阅都是耍流浪！我们修改下 store.subscribe 方法，增加退订功能</p>
        <div class="bottom"><pre>  <span class="pl-k">function</span> <span class="pl-en">subscribe</span>(<span class="pl-smi">listener</span>) {
            <span class="pl-smi">listeners</span>.<span class="pl-c1">push</span>(listener);
            <span class="pl-k">return</span> <span class="pl-k">function</span> <span class="pl-en">unsubscribe</span>() {
            <span class="pl-k">const</span> <span class="pl-c1">index</span> <span class="pl-k">=</span> <span class="pl-smi">listeners</span>.<span class="pl-c1">indexOf</span>(listener)
            <span class="pl-smi">listeners</span>.<span class="pl-c1">splice</span>(index, <span class="pl-c1">1</span>)
            }
        }</pre></div>
        <p>使用</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">unsubscribe</span> <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-en">subscribe</span>(() <span class="pl-k">=&gt;</span> {
        <span class="pl-k">let</span> state <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-en">getState</span>();
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(<span class="pl-smi">state</span>.<span class="pl-smi">counter</span>.<span class="pl-smi">count</span>);
        });
        <span class="pl-c"><span class="pl-c">/*</span>退订<span class="pl-c">*/</span></span>
        <span class="pl-en">unsubscribe</span>();</pre></div>
        <h4>中间件拿到的store</h4>
        <p>现在的中间件拿到了完整的 store，他甚至可以修改我们的 subscribe 方法，按照最小开放策略，我们只用把 getState 给中间件就可以了！因为我们只允许你用 getState 方法！</p>
        <p>修改下 applyMiddleware 中给中间件传的 store</p>
        <div class="bottom"><pre><span class="pl-c"><span class="pl-c">/*</span>const chain = middlewares.map(middleware =&gt; middleware(store));<span class="pl-c">*/</span></span>
        <span class="pl-k">const</span> <span class="pl-c1">simpleStore</span> <span class="pl-k">=</span> { getState<span class="pl-k">:</span> <span class="pl-smi">store</span>.<span class="pl-smi">getState</span> };
        <span class="pl-k">const</span> <span class="pl-c1">chain</span> <span class="pl-k">=</span> <span class="pl-smi">middlewares</span>.<span class="pl-en">map</span>(<span class="pl-smi">middleware</span> <span class="pl-k">=&gt;</span> <span class="pl-en">middleware</span>(simpleStore));</pre></div>
        <h4>compose</h4>
        <p>我们的 applyMiddleware 中，把  [A, B, C] 转换成 A(B(C(next)))，是这样实现的</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">chain</span> <span class="pl-k">=</span> [<span class="pl-c1">A</span>, <span class="pl-c1">B</span>, <span class="pl-c1">C</span>];
        <span class="pl-k">let</span> dispatch <span class="pl-k">=</span> <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span>;
        <span class="pl-smi">chain</span>.<span class="pl-c1">reverse</span>().<span class="pl-en">map</span>(<span class="pl-smi">middleware</span> <span class="pl-k">=&gt;</span> {
        dispatch <span class="pl-k">=</span> <span class="pl-en">middleware</span>(dispatch);
        });</pre></div>
        <p>redux 提供了一个 compose 方式，可以帮我们做这个事情</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">chain</span> <span class="pl-k">=</span> [<span class="pl-c1">A</span>, <span class="pl-c1">B</span>, <span class="pl-c1">C</span>];
        dispatch <span class="pl-k">=</span> <span class="pl-en">compose</span>(<span class="pl-k">...</span>chain)(<span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span>)</pre></div>
        <p>看下他是如何实现的</p>
        <div class="bottom"><pre><span class="pl-k">export</span> <span class="pl-c1">default</span> <span class="pl-k">function</span> <span class="pl-en">compose</span>(<span class="pl-k">...</span><span class="pl-v">funcs</span>) {
        <span class="pl-k">if</span> (<span class="pl-smi">funcs</span>.<span class="pl-c1">length</span> <span class="pl-k">===</span> <span class="pl-c1">1</span>) {
            <span class="pl-k">return</span> funcs[<span class="pl-c1">0</span>]
        }
        <span class="pl-k">return</span> <span class="pl-smi">funcs</span>.<span class="pl-en">reduce</span>((<span class="pl-smi">a</span>, <span class="pl-smi">b</span>) <span class="pl-k">=&gt;</span> (<span class="pl-k">...</span><span class="pl-v">args</span>) <span class="pl-k">=&gt;</span> <span class="pl-en">a</span>(<span class="pl-en">b</span>(<span class="pl-k">...</span>args)))
        }</pre></div>
        <p>当然 compose 函数对于新人来说可能比较难理解，你只需要他是做什么的就行啦！</p>
        <h4>省略initState</h4>
        <p>有时候我们创建 store 的时候不传 initState，我们怎么用？</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">createStore</span>(reducer, {}, rewriteCreateStoreFunc);</pre></div>
        <p>redux 允许我们这样写</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">createStore</span>(reducer, rewriteCreateStoreFunc);</pre></div>
        <p>我们仅需要改下 createStore 函数，如果第二个参数是一个object，我们认为他是 initState，如果是 function，我们就认为他是 rewriteCreateStoreFunc。</p>
        <div class="bottom"><pre><span class="pl-k">function</span> <span class="pl-en">craeteStore</span>(<span class="pl-smi">reducer</span>, <span class="pl-smi">initState</span>, <span class="pl-smi">rewriteCreateStoreFunc</span>){
            <span class="pl-k">if</span> (<span class="pl-k">typeof</span> initState <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">'</span>function<span class="pl-pds">'</span></span>){
            rewriteCreateStoreFunc <span class="pl-k">=</span> initState;
            initState <span class="pl-k">=</span> <span class="pl-c1">undefined</span>;
        }
        <span class="pl-k">...</span>
        }</pre></div>
        <h4>2 行代码的 replaceReducer</h4>
        <p>reducer 拆分后，和组件是一一对应的。我们就希望在做按需加载的时候，reducer也可以跟着组件在必要的时候再加载，然后用新的 reducer 替换老的 reducer。</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">createStore</span> <span class="pl-k">=</span> <span class="pl-k">function</span> (<span class="pl-smi">reducer</span>, <span class="pl-smi">initState</span>) {
        <span class="pl-k">...</span>
        <span class="pl-k">function</span> <span class="pl-en">replaceReducer</span>(<span class="pl-smi">nextReducer</span>) {
            reducer <span class="pl-k">=</span> nextReducer
            <span class="pl-c"><span class="pl-c">/*</span>刷新一遍 state 的值，新来的 reducer 把自己的默认状态放到 state 树上去<span class="pl-c">*/</span></span>
            <span class="pl-en">dispatch</span>({ type<span class="pl-k">:</span> <span class="pl-c1">Symbol</span>() })
        }
        <span class="pl-k">...</span>
        <span class="pl-k">return</span> {
            <span class="pl-k">...</span>
            replaceReducer
        }
        }</pre></div>
        <p>我们来尝试使用下</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">reducer</span> <span class="pl-k">=</span> <span class="pl-en">combineReducers</span>({
        counter<span class="pl-k">:</span> counterReducer
        });
        <span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">createStore</span>(reducer);

        <span class="pl-c"><span class="pl-c">/*</span>生成新的reducer<span class="pl-c">*/</span></span>
        <span class="pl-k">const</span> <span class="pl-c1">nextReducer</span> <span class="pl-k">=</span> <span class="pl-en">combineReducers</span>({
        counter<span class="pl-k">:</span> counterReducer,
        info<span class="pl-k">:</span> infoReducer
        });
        <span class="pl-c"><span class="pl-c">/*</span>replaceReducer<span class="pl-c">*/</span></span>
        <span class="pl-smi">store</span>.<span class="pl-en">replaceReducer</span>(nextReducer);</pre></div>
        <p>replaceReducer 示例源码见 <a href="https://github.com/frontend9/redux-demo/tree/master/demo-5">demo-5</a></p>
        <h4>bindActionCreators</h4>
        <p>bindActionCreators 我们很少很少用到，一般只有在 react-redux 的 connect 实现中用到。</p>
        <p>他是做什么的？他通过闭包，把 dispatch 和 actionCreator 隐藏起来，让其他地方感知不到 redux 的存在。</p>
        <p>我们通过普通的方式来 隐藏 dispatch 和 actionCreator 试试，注意最后两行代码</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">reducer</span> <span class="pl-k">=</span> <span class="pl-en">combineReducers</span>({
        counter<span class="pl-k">:</span> counterReducer,
        info<span class="pl-k">:</span> infoReducer
        });
        <span class="pl-k">const</span> <span class="pl-c1">store</span> <span class="pl-k">=</span> <span class="pl-en">createStore</span>(reducer);

        <span class="pl-c"><span class="pl-c">/*</span>返回 action 的函数就叫 actionCreator<span class="pl-c">*/</span></span>
        <span class="pl-k">function</span> <span class="pl-en">increment</span>() {
        <span class="pl-k">return</span> {
            type<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>INCREMENT<span class="pl-pds">'</span></span>
        }
        }

        <span class="pl-k">function</span> <span class="pl-en">setName</span>(<span class="pl-smi">name</span>) {
        <span class="pl-k">return</span> {
            type<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>SET_NAME<span class="pl-pds">'</span></span>,
            name<span class="pl-k">:</span> name
        }
        }

        <span class="pl-k">const</span> <span class="pl-c1">actions</span> <span class="pl-k">=</span> {
        <span class="pl-en">increment</span><span class="pl-k">:</span> <span class="pl-k">function</span> () {
            <span class="pl-k">return</span> <span class="pl-smi">store</span>.<span class="pl-en">dispatch</span>(<span class="pl-smi">increment</span>.<span class="pl-c1">apply</span>(<span class="pl-c1">this</span>, <span class="pl-c1">arguments</span>))
        },
        <span class="pl-en">setName</span><span class="pl-k">:</span> <span class="pl-k">function</span> () {
            <span class="pl-k">return</span> <span class="pl-smi">store</span>.<span class="pl-en">dispatch</span>(<span class="pl-smi">setName</span>.<span class="pl-c1">apply</span>(<span class="pl-c1">this</span>, <span class="pl-c1">arguments</span>))
        }
        }
        <span class="pl-c"><span class="pl-c">/*</span>注意：我们可以把 actions 传到任何地方去<span class="pl-c">*/</span></span>
        <span class="pl-c"><span class="pl-c">/*</span>其他地方在实现自增的时候，根本不知道 dispatch，actionCreator等细节<span class="pl-c">*/</span></span>
        <span class="pl-smi">actions</span>.<span class="pl-en">increment</span>(); <span class="pl-c"><span class="pl-c">/*</span>自增<span class="pl-c">*/</span></span>
        <span class="pl-smi">actions</span>.<span class="pl-en">setName</span>(<span class="pl-s"><span class="pl-pds">'</span>九部威武<span class="pl-pds">'</span></span>); <span class="pl-c"><span class="pl-c">/*</span>修改 info.name<span class="pl-c">*/</span></span></pre></div>
        <p>我眼睛一看，这个 actions 生成的时候，好多公共代码，提取一下</p>
        <div class="bottom"><pre><span class="pl-k">const</span> <span class="pl-c1">actions</span> <span class="pl-k">=</span> <span class="pl-en">bindActionCreators</span>({ increment, setName }, <span class="pl-smi">store</span>.<span class="pl-smi">dispatch</span>);</pre></div>
        <p>来看一下 bindActionCreators 的源码，超级简单（就是生成了刚才的 actions）</p>
        <div class="bottom"><pre><span class="pl-c"><span class="pl-c">/*</span>核心的代码在这里，通过闭包隐藏了 actionCreator 和 dispatch<span class="pl-c">*/</span></span>
        <span class="pl-k">function</span> <span class="pl-en">bindActionCreator</span>(<span class="pl-smi">actionCreator</span>, <span class="pl-smi">dispatch</span>) {
        <span class="pl-k">return</span> <span class="pl-k">function</span> () {
            <span class="pl-k">return</span> <span class="pl-en">dispatch</span>(<span class="pl-smi">actionCreator</span>.<span class="pl-c1">apply</span>(<span class="pl-c1">this</span>, <span class="pl-c1">arguments</span>))
        }
        }

        <span class="pl-c"><span class="pl-c">/*</span> actionCreators 必须是 function 或者 object <span class="pl-c">*/</span></span>
        <span class="pl-k">export</span> <span class="pl-c1">default</span> <span class="pl-k">function</span> <span class="pl-en">bindActionCreators</span>(<span class="pl-smi">actionCreators</span>, <span class="pl-smi">dispatch</span>) {
        <span class="pl-k">if</span> (<span class="pl-k">typeof</span> actionCreators <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">'</span>function<span class="pl-pds">'</span></span>) {
            <span class="pl-k">return</span> <span class="pl-en">bindActionCreator</span>(actionCreators, dispatch)
        }

        <span class="pl-k">if</span> (<span class="pl-k">typeof</span> actionCreators <span class="pl-k">!==</span> <span class="pl-s"><span class="pl-pds">'</span>object<span class="pl-pds">'</span></span> <span class="pl-k">||</span> actionCreators <span class="pl-k">===</span> <span class="pl-c1">null</span>) {
            <span class="pl-k">throw</span> <span class="pl-k">new</span> <span class="pl-en">Error</span>()
        }

        <span class="pl-k">const</span> <span class="pl-c1">keys</span> <span class="pl-k">=</span> <span class="pl-c1">Object</span>.<span class="pl-c1">keys</span>(actionCreators)
        <span class="pl-k">const</span> <span class="pl-c1">boundActionCreators</span> <span class="pl-k">=</span> {}
        <span class="pl-k">for</span> (<span class="pl-k">let</span> i <span class="pl-k">=</span> <span class="pl-c1">0</span>; i <span class="pl-k">&lt;</span> <span class="pl-smi">keys</span>.<span class="pl-c1">length</span>; i<span class="pl-k">++</span>) {
            <span class="pl-k">const</span> <span class="pl-c1">key</span> <span class="pl-k">=</span> keys[i]
            <span class="pl-k">const</span> <span class="pl-c1">actionCreator</span> <span class="pl-k">=</span> actionCreators[key]
            <span class="pl-k">if</span> (<span class="pl-k">typeof</span> actionCreator <span class="pl-k">===</span> <span class="pl-s"><span class="pl-pds">'</span>function<span class="pl-pds">'</span></span>) {
            boundActionCreators[key] <span class="pl-k">=</span> <span class="pl-en">bindActionCreator</span>(actionCreator, dispatch)
            }
        }
        <span class="pl-k">return</span> boundActionCreators
        }</pre></div>
        <p>bindActionCreators 示例源码见 <a href="https://github.com/frontend9/redux-demo/tree/master/demo-8">demo-8</a></p>
        <h4>大功告成</h4>
        <p>完整的示例源码见 <a href="https://github.com/frontend9/redux-demo/tree/master/demo-9">demo-9</a>，你可以和 <a href="https://github.com/reduxjs/redux/issues">redux</a> 源码做一下对比，你会发现，我们已经实现了 redux 所有的功能了。</p>
        <p>当然，为了保证代码的理解性，我们少了一些参数验证。比如 <code>createStore(reducer)</code>的参数 reducer 必须是 function 等等。</p>
        <h3><div id="practice">最佳实践</div></h3>
        <h4>纯函数</h4>
        <p>什么是纯函数？</p>
        <p>纯函数是这样一种函数，即相同的输入，永远会得到相同的输出，而且没有任何可观察的副作用。</p>
        <p>通俗来讲，就两个要素</p>
        <ol>
        <li>相同的输入，一定会得到相同的输出</li>
        <li>不会有 “触发事件”，更改输入参数，依赖外部参数，打印 log 等等副作用</li>
        </ol>
        <div class="bottom"><pre><span class="pl-c"><span class="pl-c">/*</span>不是纯函数，因为同样的输入，输出结果不一致<span class="pl-c">*/</span></span>
        <span class="pl-k">function</span> <span class="pl-en">a</span>( <span class="pl-smi">count</span> ){
        <span class="pl-k">return</span> count <span class="pl-k">+</span> <span class="pl-c1">Math</span>.<span class="pl-c1">random</span>();
        }

        <span class="pl-c"><span class="pl-c">/*</span>不是纯函数，因为外部的 arr 被修改了<span class="pl-c">*/</span></span>
        <span class="pl-k">function</span> <span class="pl-en">b</span>( <span class="pl-smi">arr</span> ){
            <span class="pl-k">return</span> <span class="pl-smi">arr</span>.<span class="pl-c1">push</span>(<span class="pl-c1">1</span>);
        }
        <span class="pl-k">let</span> arr <span class="pl-k">=</span> [<span class="pl-c1">1</span>, <span class="pl-c1">2</span>, <span class="pl-c1">3</span>];
        <span class="pl-en">b</span>(arr);
        <span class="pl-en">console</span>.<span class="pl-c1">log</span>(arr); <span class="pl-c"><span class="pl-c">//</span>[1, 2, 3, 1]</span>

        <span class="pl-c"><span class="pl-c">/*</span>不是纯函数，以为依赖了外部的 x<span class="pl-c">*/</span></span>
        <span class="pl-k">let</span> x <span class="pl-k">=</span> <span class="pl-c1">1</span>;
        <span class="pl-k">function</span> <span class="pl-en">c</span>( <span class="pl-smi">count</span> ){
            <span class="pl-k">return</span> count <span class="pl-k">+</span> x;
        }</pre></div>
        <p>我们的 reducer 计划函数，就必须是一个纯函数！</p>
        <p><strong>只要传入参数相同，返回计算得到的下一个 state 就一定相同。没有特殊情况、没有副作用，没有 API 请求、没有变量修改，单纯执行计算。</strong></p>
        <h3><div id="summary">总结</div></h3>
        <p>到了最后，我想把 redux 中关键的名词列出来，你每个都知道是干啥的吗？</p>
        <ul>
        <li>
        <p>createStore</p>
        <p>创建 store 对象，包含 getState, dispatch, subscribe, replaceReducer</p>
        </li>
        <li>
        <p>reducer</p>
        <p>reducer 是一个计划函数，接收旧的 state 和 action，生成新的 state</p>
        </li>
        <li>
        <p>action</p>
        <p>action 是一个对象，必须包含 type 字段</p>
        </li>
        <li>
        <p>dispatch</p>
        <p><code>dispatch( action )</code> 触发 action，生成新的 state</p>
        </li>
        <li>
        <p>subscribe</p>
        <p>实现订阅功能，每次触发 dispatch 的时候，会执行订阅函数</p>
        </li>
        <li>
        <p>combineReducers</p>
        <p>多 reducer 合并成一个 reducer</p>
        </li>
        <li>
        <p>replaceReducer</p>
        <p>替换 reducer 函数</p>
        </li>
        <li>
        <p>middleware</p>
        <p>扩展 dispatch 函数！</p>
        </li>
        </ul>
        <p>你再看 redux 流程图，是不是大彻大悟了？</p>
        <p><a target="_blank" rel="noopener noreferrer" href="https://user-images.githubusercontent.com/12526493/48312444-8ff2e100-e5e9-11e8-844a-48ffd9933265.png"><img src="https://user-images.githubusercontent.com/12526493/48312444-8ff2e100-e5e9-11e8-844a-48ffd9933265.png" alt="redux 流程图" style="max-width:100%;"></a></p>
        (redux 流程图)
    </div>
            
</body>
</html>

