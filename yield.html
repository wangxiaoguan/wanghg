<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。
ES6定义generator标准的哥们借鉴了Python的generator的概念和语法，如果你对Python的generator很熟悉，那么ES6的generator就是小菜一碟了。
如果你对Python还不熟，赶快恶补Python教程！。

    我们先复习函数的概念。一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果：
next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。
当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。
第二个方法是直接用for ... of循环迭代generator对象，这种方式不需要我们自己判断done：
</body>
<script>

// function* foo(x) {
//     yield x + 1;
//     yield x + 2;
//     return x + 3;
// }
// foo(1)
// var foo = foo(1)
// console.log(foo.next())
// console.log(foo.next())
// console.log(foo.next())
// console.log(foo(2).next())
// console.log(foo(3).next())
// console.log(foo(4).next())

// var foo = function *() { // 没错，尼玛还可以这样写
//   var x = 1;
//   var y =  yield (x + 1);
//   console.log(y)
//   var z = yield (x + y);
//   console.log(z)
//   return z;
// }() // 你必须先执行一下Generator函数，才能把遍历器返回给某个变量
// var a = foo.next(); // 第一次执行next()不可以传参
// var b = foo.next(3);
// var c = foo.next(5);
// console.log(a,b,c)//2,4,5

   
</script>
</html>