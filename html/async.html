<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    generator（生成器）是ES6标准引入的新的数据类型。一个generator看上去像一个函数，但可以返回多次。
ES6定义generator标准的哥们借鉴了Python的generator的概念和语法，如果你对Python的generator很熟悉，那么ES6的generator就是小菜一碟了。
如果你对Python还不熟，赶快恶补Python教程！。

    我们先复习函数的概念。一个函数是一段完整的代码，调用一个函数就是传入参数，然后返回结果：
next()方法会执行generator的代码，然后，每次遇到yield x;就返回一个对象{value: x, done: true/false}，然后“暂停”。返回的value就是yield的返回值，done表示这个generator是否已经执行结束了。如果done为true，则value就是return的返回值。
当执行到done为true时，这个generator对象就已经全部执行完毕，不要再继续调用next()了。
第二个方法是直接用for ... of循环迭代generator对象，这种方式不需要我们自己判断done：
</body>
<script>
// async function timeout() {
//     return 'hello world'
// }
// timeout().then(data=>{
//     console.log(data)
// });
// // console.log(timeout())
// console.log('虽然在后面，但是我先执行');
// async function timeout(flag) {
//     if (flag) {
//         return 'hello world'
//     } else {
//         throw 'my god, failure'
//     }
// }
// console.log(timeout(true))  // 调用Promise.resolve() 返回promise 对象。
// console.log(timeout(false)); // 调用Promise.reject() 返回promise 对象。
// timeout(false).catch(data=>{
//     console.log(data)
// })

// function doubleAfter2seconds(num) {
//     return new Promise((resolve, reject) => {
//         setTimeout(() => {
//             resolve(2 * num)
//         }, 1000);
//     } )
// }

// async function testResult() {
//     let result = await doubleAfter2seconds(30);
//     // let result = doubleAfter2seconds(30);
//     console.log(result);
// }
// testResult();
// async function testResult() {
//     let first = await doubleAfter2seconds(30);
//     let second = await doubleAfter2seconds(50);
//     let third = await doubleAfter2seconds(30);
//     console.log(first + second + third);
// }

function* foo(x) {
    yield x + 1;
    yield x + 2;
    return x + 3;
}
// foo(1)
var foo = foo(1)
console.log(foo.next())
console.log(foo.next())
console.log(foo.next())
// console.log(foo(2).next())
// console.log(foo(3).next())
// console.log(foo(4).next())

// var foo = function *() { // 没错，尼玛还可以这样写
//   var x = 1;
//   var y =  yield (x + 1);
//   console.log(y)
//   var z = yield (x + y);
//   console.log(z)
//   return z;
// }() // 你必须先执行一下Generator函数，才能把遍历器返回给某个变量
// var a = foo.next(); // 第一次执行next()不可以传参
// var b = foo.next(3);
// var c = foo.next(5);
// console.log(a,b,c)//2,4,5

    // var p1 = new Promise((pass,fail)=>{
    //     setTimeout(()=>{
    //         pass(12)
    //     },1000)
    // })
    // console.log('1111111')
    // var p2 = new Promise((pass,fail)=>{
    //     setTimeout(()=>{
    //         pass(12)
    //     },2000)
    // })
    // console.log('2222222')
    // var p3 = new Promise((pass,fail)=>{
    //     setTimeout(()=>{
    //         pass(12)
    //     },3000)
    // })
    // console.log('33333333')
    // async function get(){
    //     let num = await p1
    //     let num1 = await p2
    //     let num2 = await p3
    //     console.log(num)
    //     console.log(num1)
    //     console.log(num2)
    // }
    // get()

//     async function asyncAwaitFn(str) {
//     return await new Promise((resolve, reject) => {
//         setTimeout(() => {
//             resolve(str)
//         }, 1000);
//     })
// }

// const serialFn = async () => { //串行执行

//     console.time('serialFn')
//     console.log(await asyncAwaitFn('string 1'));
//     console.log(await asyncAwaitFn('string 2'));
//     console.timeEnd('serialFn')
// }

// serialFn();
</script>
</html>