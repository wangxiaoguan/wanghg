<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>

</body>
<script>
    // //concat() 方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回一个新数组。
    // var a = [1,2,3,4,5];
    // var b = [5,6];
    // var c = a.concat(b); // a,b 数组都不变，c变成了1,2,3,4,5,5,6

    // //concat() 方法用于连接两个或多个字符串。该方法没有改变原有字符串，但是会返回连接两个或多个字符串新字符串。
    // var str1 = "Hello ";
    // var str2 = "world!";
    // var n = str1.concat(str2);//str1,str2 字符串不变，c  "Hello world!"

    // var time = new Date("2019-05-13T02:12:06.117Z").getTime()
    // console.log(time)

    // var result = 1-undefined
    // console.log(result,1>NaN)

    // var arr = [1,2,3,[4,5],[6,7,[8,9]]];
    // // var arr2 = [].concat(...arr)
    // // var arr2 = arr.flat(3)
    // var arr2 = arr.join(',').split(',')
    // console.log(arr2)

    // var arr = [1,2,3,4,5,6,7,8,9,'b','c',2,4,8,2,1]
    // var arr2 = [1,2,5,10,"a",'b']
    // var list = {...arr,...arr2}
    // var list2 = new Set(list)
    // console.log(list)
    // var arr2 = arr.slice(0,3)
    // var arr2 = arr.splice(8)
    // console.log(arr,arr2)
    // console.log([...new Set(arr)])
    // console.log(Array.from(new Set(arr)))
    // console.log(arr.includes(11))//判断数组是否存在某元素

    //Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。
    // const target = { a: 1, b: 2 };
    // const source = { b: 4, c: 5 };
    // const source2 = { c: 4, d: 7 };
    // const obj = Object.assign(target,source,source2);
    // console.log(target);                        //{ a: 1, b: 4, c: 5, d: 7 }
    // console.log(source);                        //{ b: 4, c: 5 }
    // console.log(source2);                       //{ c: 4, d: 7 }
    // console.log(obj);                           //{ a: 1, b: 4, c: 5, d: 7 }

    // function deepCopy(obj) {
    //     var result = Array.isArray(obj) ? [] : {};
    //     for (var key in obj) {
    //         if (obj.hasOwnProperty(key)) {
    //         if (typeof obj[key] === 'object') {
    //             result[key] = deepCopy(obj[key]);   //递归复制
    //         } else {
    //             result[key] = obj[key];
    //         }
    //         }
    //     }
    //     return result;
    // }

    //hasOwnProperty表示是否有自己的属性。这个方法会查找一个对象是否有某个属性，但是不会去查找它的原型链。
    // var obj = {
    //     a: 1,
    //     fn: function(){},
    //     c:{d: 5}
    // };
    // console.log(obj.hasOwnProperty('a'));       // true
    // console.log(obj.hasOwnProperty('fn'));      // true
    // console.log(obj.hasOwnProperty('c'));       // true
    // console.log(obj.c.hasOwnProperty('d'));     // true
    // console.log(obj.hasOwnProperty('d'));       // false, obj对象没有d属性
    
    var str = new String();
    // split方法是String这个对象的方法，str对象本身是没有这个split这个属性的
    // console.log(str.hasOwnProperty('split'));               // false
    // console.log(String.prototype.hasOwnProperty('split'));  // true


    // console.log(Array.from('foo'));             //["f", "o", "o"]
    // console.log(Array.from(123456));            //[]
    // console.log(Array(7).length)

    var array = [
        { number: {name:'wang',fn:function(){
            for(let i=0;i<5;i++){
                console.log(i)
            }
        }} },
        { number: 2 ,arr:[1,2,3,4,5,6,7,8]},
        { number: 3 }
    ];
    function copy (obj) {
        var newobj = obj.constructor === Array ? [] : {};
        if(typeof obj !== 'object'){
            return;
        }
        for(var i in obj){
        newobj[i] = typeof obj[i] === 'object' ?
        copy(obj[i]) : obj[i];
        }
        return newobj
    }
    var copyArray = copy(array)
    console.log(copyArray)

    console.log(JSON.parse(JSON.stringify(copyArray)))
    //JSON.parse(JSON.stringify(copyArray))对obj中的普通对象和数组都能拷贝，然而date对象成了字符串，函数直接就不见了，正则成了一个空对象。


    var txt = '{ "sites" : [' +
'{ "name":"菜鸟教程" , "url":"www.runoob.com" },' +
'{ "name":"google" , "url":"www.google.com" },' +
'{ "name":"微博" , "url":"www.weibo.com" } ]}';
var obj = eval(txt)
console.log(obj)
var obj = eval ("(" + txt + ")");

    // // // var arr2 = arr.flat(3)
    // // var arr2 = arr.join(',').split(',')
    // // console.log(arr2)

    // // var arr = [1,2,3,4,5,6,7,8,9]
    // // // var arr2 = arr.slice(0,3)
    // // var arr2 = arr.splice(8)
    // // console.log(arr,arr2)


    // let arr = [1,[2,[[3,4],5],6]];
    // let arr2 = arr.join(',').split(',');
    // console.log(arr2);//["1", "2", "3", "4", "5", "6"]

    //     //或
    // let c=[1,3,4,5,[6,[0,1,5],9],[2,5,[1,5]],[5]];
    // console.log(c.toString())

    // //所以使用concat方法只能把二维数组转为一维数组
    // let tempArr4 = [[1,2],'3','4',[5,6],[7]];
    // console.log([].concat.apply([],tempArr4)); // [1, 2, "3", "4", 5, 6, 7]

    // //使用flat
    // //flat()、flatMap()为es6新增加的方法,该方法返回一个新数组，对原数据没有影响。
    // //flat()默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将flat()方法的参数写成一个整数，表示想要拉平的层数，默认为1。

    // console.log([1, 2, [3, [4, 5]]].flat())
    // // [1, 2, 3, [4, 5]]

    // console.log([1, 2, [3, [4, 5]]].flat(2))
    // // [1, 2, 3, 4, 5]
    // //如果不管有多少层嵌套，都要转成一维数组，可以用Infinity关键字作为参数。
    // console.log([1, [2, [3]]].flat(Infinity))
    // // [1, 2, 3]


    // var arr = [1,2,3,4,5,6,3,2,7,9,8,'1']
    // console.log(Array.from(new Set(arr)))

</script>
</html>