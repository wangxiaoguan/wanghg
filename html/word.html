<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    <!-- 描点跳转 -->
    <a href="#node">节点</a>
    <div id="node" >内容</div>
    http://www.hbsqi.com/officialWebFront#/index
–save(-S)：将保存配置信息到pacjage.json的dependencies节点中。
–save-dev(-D)：将保存配置信息到pacjage.json的devDependencies节点中。
dependencies：运行时的依赖，发布后，即生产环境下还需要用的模块
devDependencies：开发时的依赖。里面的模块是开发时用的，发布时用不到它。
@connect(
    state=>({
        pageData:state.table.pageData,
    }),
    dispatch=>({
        getPageData:n=>dispatch(getPageData(n)), 
    })
)
装饰器，需要安装模块 cnpm i babel-plugin-transform-decorators-legacy -D，然后在babel中配置：
{
    "plugins": [
      "transform-decorators-legacy", 
    ]
}
css样式表：
    column-count:3;/*分开几列*/
    column-gap:30px;/*每列之间间隔*/


    !DOCTYPE html——定义文档类型
    html——文档根标签，双标签
    head文档头标签，双标签

    li:nth-child(2){color: red; }
    ::selection{background:pink;color:red;}
    label::before{content:"你好";}
    label::after{content:"大家好";}
    before与after只能在双标签上使用，并且使用单冒号和双冒号都一样，IE8不支持
    h1+p{background:red;}/*p后面紧跟第一个h3*/
    h1~p{background: red;}/*p后面所有的h3*/
    div>ul>li>span{color: red;}

    @media screen and (min-width:100px) and (max-width:1000px){
        html{
            background:#000;
        }
    }
    @media screen and (min-width:1001px) and (max-width:1920px){
        html{
            background:#0f0;
        }
    }
    @media screen and (min-width:1921px){
        html{
            background:#00f;
        }
    }
 
    单文本省略号
    .text{
        width:200px;/*必须是固定宽度值*/
        overflow:hidden;/*超出部分隐藏*/
        text-overflow:ellipsis;/*超出部分显示省略号*/
        white-space:nowrap;/*规定段落中的文本不进行换行 */
    }
    多行文本省略号
    .text{
        width:200px;/*必须是固定宽度值*/
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 3;
        overflow:hidden;/*超出部分隐藏*/
    }

    用fetch向后端发送post请求，会产生两个请求OPTIONS和POST的原因
    关于跨域
    根据浏览器同源策略（协议、域名、端口一致为同源），凡是发送请求的源与当前页面的源不同的即为跨域。同源策略用于隔离潜在的恶意文件。
    解决方式
    JSONP：只支持GET，不支持POST请求；
    原理：浏览器只对XHR请求有同源限制，对script标签src属性，link标签ref属性和img标签src属性没有限制。
    代理：使用代理去避开跨域请求，写一个后台接口，在后端去调用该不通源请求地址；
    服务端修改：在服务端页面添加header限制：
    Header(‘Access-Control-Allow-Origin:*’)//允许所有来源访问
    Header(‘Access-Control-Allow-Method:POST,GET’)//允许访问的方式
    关于CORS跨域资源共享机制
    CORS跨域资源共享机制，允许web应用服务器进行跨域访问控制。
    CORS允许在下列场景中使用跨域http请求：
    XMLHttpRequest或Fetch发起的跨域HTTP请求；Web字体；WebGL贴图；样式表（使用CSSOM）；
    使用drawImage将Images/video 画面绘制到canvas。
    CORS标准新增了一组http首部字段，允许服务器声明哪些源站通过浏览器可以访问哪些资源。
    另外，规范要求，对那些可能对服务器数据产生副作用的请求，必须首先使用options方法发起预检请求，
    获知服务端是否允许该跨域请求，允许之后才发起实际的HTTP请求，在预检返回的结果中，
    服务端也可以通知客户端是否需要携带身份凭证（cookies和http认证相关数据）。


    fetch请求和ajax请求
        ajax
        1.是XMLHTTPRequest的一个实例

        2.只有当状态为200或者304时才会请求成功

        3.格式零散，容易出现回调地狱的问题

        fetch
        1.fetch是基于promise实现的，也可以结合async/await

        2.fetch请求默认是不带cookie的，需要设置fetch（URL，{credentials:’include’})。 

        Credentials有三种参数：same-origin，include，*

        3.服务器返回400 500 状态码时并不会reject，只有网络出错导致请求不能完成时，fetch才会被reject

        4.所有版本的 IE 均不支持原生 Fetch

        5.fetch是widow的一个方法

    $(document).ready(function(){
        
    });
    windows.onload()
    当 DOM（文档对象模型） 已经加载，并且页面（包括图像）已经完全呈现时，会发生 ready 事件。

    一个简单的零配置命令行HTTP服务器 - http-server (nodeJs)
    http-server 是一个简单的零配置命令行HTTP服务器, 基于 nodeJs.

    安装 (全局安装加 -g) : npm install http-server 
    Windows 下使用:
    在站点目录下开启命令行输入http-server
    访问: http://localhost:8080 or http://127.0.0.1:8080 
    使用于package.json
    "scripts": {
        "start": "http-server -a 0.0.0.0 -p 8000",
    }
    let reg = 'edf'
    let str = 'abcdefg'
    let regStr = str.replace(new RegExp(reg,'ig'),'')
</body>
</html>